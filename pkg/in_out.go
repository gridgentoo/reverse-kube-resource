package pkg

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"io/fs"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"

	"golang.org/x/tools/go/ast/astutil"
	"k8s.io/apimachinery/pkg/runtime/serializer"
	"k8s.io/client-go/kubernetes/scheme"
)

func checkFatal(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "%w", err)
		os.Exit(1)
	}
}

func printImports(pkg string, obj []Import, buf *bytes.Buffer) {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "", fmt.Sprintf("package %v", pkg), 0)
	checkFatal(err)
	for _, o := range obj {
		astutil.AddNamedImport(fset, f, o.name, o.path)
	}

	ast.SortImports(fset, f)
	printer.Fprint(buf, fset, f)
}

func printLines(rawVars []RawVar, buf *bytes.Buffer, kubermatic bool) {
	if len(rawVars) == 0 {
		return
	}
	single := false
	if !kubermatic {
		if len(rawVars) == 1 && len(rawVars[0].helpers) == 0 {
			single = true
			fmt.Fprintf(buf, "var ")
		} else {
			fmt.Fprintln(buf, "var (")
		}
	}
	for _, o := range rawVars {
		if !single {
			fmt.Fprintf(buf, "// %v %q\n", o.kind, o.name)
		}
		for _, l := range o.helpers {
			fmt.Fprintln(buf, l)
		}
		if len(o.helpers) != 0 {
			fmt.Fprintln(buf, "")
		}
		for _, l := range o.lines {
			fmt.Fprintln(buf, l)
		}
		fmt.Fprintln(buf, "")
	}
	if !single && !kubermatic {
		fmt.Fprintln(buf, ")")
	}
}

func Print(pkg, boilerplate string, imports []Import, vars []RawVar, kubermatic bool) {
	var buf bytes.Buffer
	if boilerplate != "" {
		bytes, err := ioutil.ReadFile(boilerplate)
		checkFatal(err)
		n := time.Now()
		y, _, _ := n.Date()
		str := strings.Replace(string(bytes), "YEAR", fmt.Sprintf("%d", y), 1)
		fmt.Fprintf(&buf, "%v\n", str)
	}
	fmt.Fprintf(&buf, "// Code generated by reverse-kube-resource. DO NOT EDIT.\n\n")
	printImports(pkg, imports, &buf)
	printLines(vars, &buf, kubermatic)
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("%v", string(buf.Bytes()))
		checkFatal(err)
	}
	fmt.Printf("%v", string(formatted))
}

func readFile(path string) (all [][]byte) {
	data, err := os.ReadFile(path)
	checkFatal(err)
	split := strings.Split(string(data), "---")
	for i, _ := range split {
		if len(split[i]) != 0 {
			all = append(all, []byte(split[i]))
		}
	}
	return
}

func read(path string) (all [][]byte) {
	fi, err := os.Stat(path)
	checkFatal(err)
	if fi.IsDir() {
		err := filepath.Walk(path, func(p string, i fs.FileInfo, err error) error {
			pl := strings.ToLower(p)
			if !(strings.HasSuffix(pl, ".yaml") || strings.HasSuffix(pl, ".yml")) || i.IsDir() {
				return nil
			}
			all = append(all, readFile(p)...)
			return nil
		})
		checkFatal(err)
	} else {
		all = readFile(path)
	}
	return all
}

func updateCRDScheme(crdPackages string) error {
	if crdPackages == "" {
		return nil
	}
	packages := strings.Split(crdPackages, ",")
	for _, p := range packages {
		if err := updateCRDScheme(p); err != nil {
			return err
		}
	}
	return nil
}

func ReadInput(path, crdPackages string) (objs []object) {
	d := read(path)
	err := updateCRDScheme(crdPackages)
	checkFatal(err)
	codecs := serializer.NewCodecFactory(scheme.Scheme)
	for _, data := range d {
		objs = append(objs, object{
			rt: getRuntimeObject(data, codecs),
			un: getUnstructuredObject(data),
		})
	}
	return
}
